#! /usr/bin/env perl
##########################################################################################################################################
######Description of this code#####
## This code is used to correct RepSeqs with possible errors generated by one insertion or deletion (1-Indel) in the linked RepSeqs.
## The input file is the output file from BarBIQ_sub_link_error.pl
##########################################################################################################################################
######how to run this code #####
###command##
## BIQ_sub_indels.pl --in inputfile --out outputfile
###expalaination##
## --in: the inputfile which is generated from BarBIQ_sub_link_error.pl.
## --out: outputfile, please set a name for your outputfile.
##########################################################################################################################################
#####Install#####
## please install the perl Module: Text::Levenshtein::XS before using this code
##########################################################################################################################################

#####code#####
use strict;
use warnings;
# use IPC::System::Simple qw(system);
use Text::Levenshtein::XS qw/distance/;

print "Now you are runing $0\n";
print "The parameters are: @ARGV\n";

##read command##
my ($i,$inputfile,$outputfile);
for($i=0; $i<=$#ARGV; $i=$i+2)
    {
        if ($ARGV[$i] eq "--in")  {$inputfile = $ARGV[$i+1];}
     elsif ($ARGV[$i] eq "--out") {$outputfile = $ARGV[$i+1];}
     else                         {die "Your input is wrong!!!\n Please input \"--in inputfile --out outputfile\"\n $!";}
    }
if(!$inputfile)   {die "Your input is wrong!!!\n Please input \"--in: inputfile\"\n $!";}
if(!$outputfile)  {die "Your input is wrong!!!\n Please input \"--out: outputfile\"\n $!";}
if(-e $outputfile){die "Your output file $outputfile is already existed!!! please check!!!\n $!";}
my $outputfile_3 = "$outputfile"."_statistic"; ## this file will save the statistic information of the possible indels, one can check this file to evaluate the threshold by himself
unlink $outputfile_3;
##read command##

##check the inputfile##
if(!(-e $inputfile)) {die "Your input file $inputfile is not existed!!! please check!!!\n $!";}
open (FILE,$inputfile) or die "Could not open file '$inputfile' $!"; # open inputfile
print "Your inputfile is:\t$inputfile\n";
my $gi=<FILE>;
chomp $gi;
my @info=split(/\s+/,$gi);
if(!(($#info == 5) && ($info[0] =~ /\Acluster_/)))
   {
    die "Your input file $inputfile is wrong!!! please check!!!\n $!";
   }
close FILE;
if ($info[3] eq "No")
   {
     die "This data is a SINGLE end data!!! Please use another code\n";
   }
print "Inputfile is OK!\nStart to calculating:\n";
##check the inputfile##

##Get one cluster's data and find the possible pair of indel and mother##
open (FILE,$inputfile) or die "Could not open file '$inputfile' $!";
chomp($gi=<FILE>); @info=split(/\s+/,$gi);
my ($cluster_name, $cluster_name_next);
if($info[0] =~ m{\Acluster_([0-9]*)}) {$cluster_name = "cluster_"."$1";}
my (@sequence, %indels, @indels, %pair_seq, %correct_IF);
push @sequence, [@info];
while($gi=<FILE>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    if($info[0] =~ m{\Acluster_([0-9]*)}) {$cluster_name_next = "cluster_"."$1";}
    if ($cluster_name_next eq $cluster_name){push @sequence, [@info];} 
  else {
         &Find_indel($cluster_name, \@sequence);
         undef @sequence;
         $cluster_name = $cluster_name_next;
         push @sequence, [@info];
        }
    }
&Find_indel($cluster_name, \@sequence);
undef @sequence;
close FILE;
##Get one cluster's data and find the possible pair of indel and mother##

##To review all the sequences and statistic all cases##
my (%pair_A_B, %pair_B_A);
open (FILE,$inputfile) or die "Could not open file '$inputfile' $!";
chomp($gi=<FILE>);@info=split(/\s+/,$gi);
undef @sequence;
if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name = "cluster_"."$1";}
push @sequence, [@info];
while($gi=<FILE>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name_next = "cluster_"."$1";}
    if ($cluster_name_next eq $cluster_name){push @sequence, [@info];}
  else {
         &Review_indel($cluster_name, \@sequence);
         undef @sequence; 
         $cluster_name = $cluster_name_next;
         push @sequence, [@info];
        }
    }
&Review_indel($cluster_name, \@sequence);
undef @sequence;
close FILE;

## print the statistic informations into a file
my (%possible_pair_A_B, %possible_pair_B_A);
open (OUTF3,'>>', $outputfile_3) or die "Could not open file '$outputfile_3' $!";
foreach my $key (keys %pair_A_B)
    {
      my @keys = split(/\s+/,$key);
      if(($pair_A_B{$key}>=$pair_B_A{$key}) && ($pair_seq{$keys[0]} <= $pair_seq{$keys[1]})) ## here incolude two threskolds: O(ID)>=O(M) and M>=ID
        {
          print OUTF3 ("$pair_A_B{$key}\t$pair_B_A{$key}\t$pair_seq{$keys[0]}\t$pair_seq{$keys[1]}\t$keys[0]\t$keys[1]\n");
          $possible_pair_A_B{$key}=$pair_A_B{$key}; $possible_pair_B_A{$key}=$pair_B_A{$key};
        }
    }
close OUTF3;
##To review all the sequences and statistic all cases##

## Use threshold to delete all the real indels###
my %delete;
my %correct;
my %ratio;
foreach my $key (keys %possible_pair_A_B)
    {
      my @keys = split(/\s+/,$key);
      my $threshold = (($pair_seq{$keys[0]}-2)/$pair_seq{$keys[0]}); ## variable thereshold for delete the indels
      if ((($possible_pair_A_B{$key}+$possible_pair_B_A{$key})/$pair_seq{$keys[0]}) >= $threshold)
          {
            if(exists $delete{$keys[0]})
               {
                print "$keys[0] has double mother!!!\n"; ## if one indel has been found has more than two possible mothers, using the ratio O(ID)/ID(highest) to choose one mother.
                if(($pair_A_B{$key}/$pair_seq{$keys[0]})>$ratio{$keys[0]})
                   {
                     $delete{$keys[0]}=$keys[1];
                     $correct{$keys[0]}=$correct_IF{$keys[1]};
                     $ratio{$keys[0]}=$pair_A_B{$key}/$pair_seq{$keys[0]};
                   }
               }
           else{
                $delete{$keys[0]}=$keys[1];
                $correct{$keys[0]}=$correct_IF{$keys[1]};
                $ratio{$keys[0]}=$pair_A_B{$key}/$pair_seq{$keys[0]};
               }
          }
     }

my $delete_no=0;
foreach my $key (keys %delete)
   { $delete_no++}
print "Totally found $delete_no indels, and start to delete them.....\n";

open (FILE,$inputfile) or die "Could not open file '$inputfile' $!";
chomp($gi=<FILE>);@info=split(/\s+/,$gi);
if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name = "cluster_"."$1";}
push @sequence, [@info];
while($gi=<FILE>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name_next = "cluster_"."$1";}
    if ($cluster_name_next eq $cluster_name){push @sequence, [@info];}
  else {
         &Delete_indel($cluster_name, \@sequence);
         undef @sequence;
         $cluster_name = $cluster_name_next;
         push @sequence, [@info];
        }
    }
&Delete_indel($cluster_name, \@sequence);
undef @sequence;
close FILE;
## Use threshold to delete all the real indels###

#Find the insertion and deletions#
sub Find_indel
     {
      my ($cluster, $seq)=@_;
      my ($i,$j);
      if ($#{$seq}>=1)
         {
          for($i=0; $i<=($#$seq-1); $i++)
             {
              for($j=$i+1; $j<=$#$seq; $j++)
                 {
                  &indels($$seq[$i][2], $$seq[$j][2], $$seq[$i][3], $$seq[$j][3]);
                 }
              }
         }
      sub indels ## for searching insertion and deletions
         {
           my ($seq1_I1, $seq2_I1, $seq1_R2, $seq2_R2) = @_;
           my $distance_I1 = distance($seq1_I1,$seq2_I1);
           my $distance_R2 = distance($seq1_R2,$seq2_R2); 
           my $repseq1="$seq1_I1"."$seq1_R2";
           my $repseq2="$seq2_I1"."$seq2_R2";
              if ($distance_I1 == 2 && $distance_R2 == 0)
                 {
                    my @seq1_I1=split(//, $seq1_I1);
                    pop @seq1_I1;
                    my $seq1_I1_one=join("",@seq1_I1);
                    my @seq2_I1=split(//, $seq2_I1);
                    pop @seq2_I1;
                    my $seq2_I1_one=join("",@seq2_I1);
                    my $distance_1_one_2 = distance($seq1_I1_one,$seq2_I1);
                    my $distance_1_2_one = distance($seq1_I1,$seq2_I1_one);
                    if($distance_1_one_2 == 1 || $distance_1_2_one == 1)
                       {
                         my $keys="$repseq1"."\t$repseq2";
                         if (!(exists $indels{$keys}))
                             {
                              $indels{$keys}=1;
                              push @indels, [($repseq1,$repseq2)];
                             }
                         $keys="$repseq2"."\t$repseq1";
                         if (!(exists $indels{$keys}))
                             {
                              $indels{$keys}=1;
                              push @indels, [($repseq2,$repseq1)];
                             }
                          $pair_seq{$repseq1}=0;
                          $pair_seq{$repseq2}=0;
                       }
                 }
           elsif ($distance_I1 == 0 && $distance_R2 == 2)
                 {
                    my @seq1_R2=split(//, $seq1_R2);
                    my @seq2_R2=split(//, $seq2_R2);
                    pop @seq1_R2;
                    my $seq1_R2_one=join("",@seq1_R2);
                    pop @seq2_R2;
                    my $seq2_R2_one=join("",@seq2_R2);
                    my $distance_1_one_2 = distance($seq1_R2_one,$seq2_R2);
                    my $distance_1_2_one = distance($seq1_R2,$seq2_R2_one);
                    # print "$repseq1\t$repseq2:\tI1\t$distance_I1\tR2\t$distance_R2\t$distance_1_one_2\t$distance_1_2_one\n";
                    if($distance_1_one_2 == 1 || $distance_1_2_one == 1)
                       {
                         my $keys="$repseq1"."\t$repseq2";
                         if (!(exists $indels{$keys}))
                             {
                              $indels{$keys}=1;
                              push @indels, [($repseq1,$repseq2)];
                             }
                         $keys="$repseq2"."\t$repseq1";
                         if (!(exists $indels{$keys}))
                             {
                              $indels{$keys}=1;
                              push @indels, [($repseq2,$repseq1)];
                             }
                          $pair_seq{$repseq1}=0;
                          $pair_seq{$repseq2}=0;
                       }
                 }
         } # end of searching insertion and deletions
    }
#end of Find the insertion and deletions#

sub Review_indel
    {
      my ($cluster, $seq)=@_;
      my ($i, $j, @possible);
      # print "$#$seq\n";
      for($i=0; $i<=$#$seq; $i++)
        {
         my $repseq="$$seq[$i][2]"."$$seq[$i][3]";
         $correct_IF{$repseq}="$$seq[$i][2]\t$$seq[$i][3]\t$$seq[$i][4]\t$$seq[$i][5]";
         if(exists $pair_seq{$repseq})
            {
              push @possible, [($repseq,$$seq[$i][1])];
              $pair_seq{$repseq}++;
            #  print "$pair_seq{$repseq}\n";
            }   
        }
      for($i=0; $i<=($#possible-1); $i++)
        {
          for($j=$i+1; $j<=$#possible; $j++)
            {
              my $pair="$possible[$i][0]\t$possible[$j][0]";
              my $pair_r="$possible[$j][0]\t$possible[$i][0]";
              if (exists $indels{$pair})
                 {
                   if($possible[$i][1] > $possible[$j][1])
                      {
                        if (exists $pair_A_B{$pair})
                          {
                           $pair_B_A{$pair}++; $pair_A_B{$pair_r}++;
                          }
                      else{
                           $pair_A_B{$pair}=0; $pair_B_A{$pair}=1;
                           $pair_A_B{$pair_r}=1; $pair_B_A{$pair_r}=0;
                          }
                      }
                 else {
                        if (exists $pair_A_B{$pair})
                          {
                           $pair_A_B{$pair}++;$pair_B_A{$pair_r}++; 
                          }
                      else{
                           $pair_A_B{$pair}=1; $pair_B_A{$pair}=0;
                           $pair_A_B{$pair_r}=0; $pair_B_A{$pair_r}=1;
                          }
                      }
                  if(!(exists $indels{$pair_r})) {print "Somthing is wrong!!\n";}
                #  print "$pair_A_B{$pair}\t$pair_B_A{$pair}\t$pair_A_B{$pair_r}\t$pair_B_A{$pair_r}\n";
                }
            }
        }
    }

sub Delete_indel
    {
     my ($cluster, $seq)=@_;
     my ($i, $j, @possible);
     open (OUTF,'>>', $outputfile) or die "Could not open file '$outputfile' $!";
     for($i=0; $i<=$#$seq; $i++)
        {
         my $repseq="$$seq[$i][2]"."$$seq[$i][3]";
         if(exists $delete{$repseq})
            {
              for($j=0; $j<=$#$seq; $j++)
                 {
                  my $repseq_m="$$seq[$j][2]"."$$seq[$j][3]";
                  if ($repseq_m eq $delete{$repseq})
                     {
                      $$seq[$j][1] = $$seq[$j][1] + $$seq[$i][1];
                      last;
                     }
                 }
              if($j>$#$seq)
                {
                 print OUTF ("$$seq[$i][0]\t$$seq[$i][1]\t$correct{$repseq}\n");
                }
            }
        }
      for($i=0; $i<=$#$seq; $i++)
        {
         my $repseq="$$seq[$i][2]"."$$seq[$i][3]";
         if(!(exists $delete{$repseq}))
           {
            print OUTF ("$$seq[$i][0]\t$$seq[$i][1]\t$$seq[$i][2]\t$$seq[$i][3]\t$$seq[$i][4]\t$$seq[$i][5]\n");
           }
        }
    close OUTF;
    }
print "Done!!!\n";

##end##

#####Author#####
#Jianshi Frank Jin

#####Version#####
#V1.001
#2018.09.03
