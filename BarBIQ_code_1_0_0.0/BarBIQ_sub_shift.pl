#! /usr/bin/env perl
##########################################################################################################################################
######Description of this code#####
## This code is used to romove the shifted RepSeqs generated by insertion or deletion errors at amplification primer sites (5â€™ end of the I1 and R2 reads).
## The inputfile file of this code is the output file from BarBIQ_sub_clustering_step_two.pl
##########################################################################################################################################
######how to run this code #####
###command##
## BarBIQ_sub_shift.pl --in inputfile --out outputfile
###explaination##
## --in: the inputfile which is generated from BarBIQ_sub_clustering_step_two.pl.
## --out: outputfile, please set a name for your outputfile
##########################################################################################################################################
#####Install#####
## None
##########################################################################################################################################

#####code#####
use strict;
use warnings;

print "Now you are runing $0\n";
print "The parameters are: @ARGV\n";

##read command##
my ($i,$inputfile,$outputfile);
my $single_end = "No"; # this is a pair end data
my $shiftcon=7;  # how many bases should be considered as a shift.
for($i=0; $i<=$#ARGV; $i=$i+2)
    {
        if ($ARGV[$i] eq "--in")  {$inputfile = $ARGV[$i+1];}
     elsif ($ARGV[$i] eq "--out") {$outputfile = $ARGV[$i+1];}
     else                         {die "Your input is wrong!!!\n Please input \"--in inputfile --out outputfile\"\n $!";}
    }
if(!$inputfile)   {die "Your input is wrong!!!\n Please input \"--in: inputfile\"\n $!";}
if(!$outputfile)  {die "Your input is wrong!!!\n Please input \"--out: outputfile\"\n $!";}
if(-e $outputfile){die "Your output file $outputfile is already existed!!! please check!!!\n $!";}
my $outputfile_I1="$outputfile"."_statistic_I1"; ### save the statistics of shift sequences of I1
my $outputfile_R2="$outputfile"."_statistic_R2"; ### save the statistics of shift sequences of R2
unlink $outputfile_I1;
unlink $outputfile_R2;
##read command##

##check the inputfile##
if(!(-e $inputfile)) {die "Your input file $inputfile is not existed!!! please check!!!\n $!";}
open (FILE,$inputfile) or die "Could not open file '$inputfile' $!"; # open inputfile
print "Your inputfile is:\n$inputfile\n";
my $gi=<FILE>;
chomp $gi;
my @info=split(/\s+/,$gi);
if(!(($#info == 3) && ($info[0] =~ /\Acluster_/)))
   {
    die "Your input file $inputfile is wrong!!! please check!!!\n $!";
   }
if ($info[3] eq "No")
   {
    print "This is a single end data!!!please use another code!!!\n";
    die;
   }
close FILE;
print "Inputfile is OK!\nStart to calculating:\n";
##check the inputfile##

##sorting the inputfile by cluster ID##
print "Sorting by cluster ID...\n";
my $inputfile_sort="$inputfile"."_sort"; ## a file for sorted inputfile by cluster ID
unlink $inputfile_sort;
my (@out,$out,$string);
open(IN, $inputfile) || die "canot open input file '$inputfile' $!";
@out = sort {$a->[0] cmp $b->[0]}
       map [(split)], <IN>;
open(SORT, '>>', $inputfile_sort) or die "Could not open file '$inputfile_sort' $!";
for $out(@out)
   {
    $string=join("\t",@$out);
    print SORT ("$string\n");
   }
close SORT;
close IN;
print "File sorting finished!!!\n";
##sorting the inputfile by cluster ID##

##Get one cluster's data and find the possible shifts##
open (FILE,$inputfile_sort) or die "Could not open file '$inputfile_sort' $!";
chomp($gi=<FILE>); @info=split(/\s+/,$gi);
my ($cluster_name, $cluster_name_next);
if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name = "cluster_"."$1";}
my @sequence;
push @sequence, [@info];
my (%shift, %shift_pair, %shift_I1, %shift_R2, %shift_I1_count, %shift_R2_count, %correct);
while($gi=<FILE>)
   {
    chomp $gi;@info=split(/\s+/,$gi);
    if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name_next = "cluster_"."$1";}
    if ($cluster_name_next eq $cluster_name) {push @sequence, [@info];} 
  else {
       &Find_shift($cluster_name, \@sequence);
       undef @sequence;
       $cluster_name = $cluster_name_next;
       push @sequence, [@info];
      }
   }
&Find_shift($cluster_name, \@sequence);
undef @sequence;
close FILE;
##Get one cluster's data and find the possible shifts##

##To review all the sequences and statistic all cases##
my (%pair_A_B_I1, %pair_B_A_I1, %pair_A_B_R2, %pair_B_A_R2);
open (FILE,$inputfile_sort) or die "Could not open file '$inputfile_sort' $!";
chomp($gi=<FILE>); @info=split(/\s+/,$gi);
if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name = "cluster_"."$1";}
push @sequence, [@info];
while($gi=<FILE>)
   {
      chomp $gi;
      @info=split(/\s+/,$gi);
      if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name_next = "cluster_"."$1";}
      if($cluster_name_next eq $cluster_name) {push @sequence, [@info];} 
    else{
       &Review_shift($cluster_name, \@sequence);
       undef @sequence;
       $cluster_name = $cluster_name_next;
       push @sequence, [@info];
        }
    }
&Review_shift($cluster_name, \@sequence);
undef @sequence;
close FILE;

## save the statistic shifts informations into files ##
my (%possible_pair_A_B_I1, %possible_pair_A_B_R2, %possible_pair_B_A_I1, %possible_pair_B_A_R2);
open (OUTFI1,'>>', $outputfile_I1) or die "Could not open file '$outputfile_I1' $!";
foreach my $key (keys %pair_A_B_I1)
    {
      my @keys = split(/\s+/,$key);
       print OUTFI1 ("$pair_A_B_I1{$key}\t$pair_B_A_I1{$key}\t$shift_I1_count{$keys[0]}\t$shift_I1_count{$keys[1]}\t$shift_I1{$key}\t$keys[0]\t$keys[1]\n"); 
      # if ($keys[0] eq "GTTTGCTCCCCACGCTTTCGAGCCTCAGCGTCAGTTATCGTCCAGTAAGCCGCCTTCGCCACTGGTGTTCCTCCTAATATCTACGCATTTCACCGCTACACTAGGAATTCCGCTTACCCCTCCGACACTCTAGTACGACAGTTTCCAATGCAGTGCCGGGGTTGAGCCCCGGGCTTTCACATCAGACTTGCCGCACCGCCTGCGCTCCCT") {print "yes2\n$pair_A_B_I1{$key}\t$pair_B_A_I1{$key}\t$shift_I1_count{$keys[0]}\t$shift_I1_count{$keys[1]}\t$shift_I1{$key}\n";}
      # if(($shift_I1_count{$keys[0]} < $shift_I1_count{$keys[1]})) ## this step include M>=S
      #  {
         #  print OUTFI1 ("$pair_A_B_I1{$key}\t$pair_B_A_I1{$key}\t$shift_I1_count{$keys[0]}\t$shift_I1_count{$keys[1]}\t$shift_I1{$key}\t$keys[0]\t$keys[1]\n");
      #    $possible_pair_A_B_I1{$key}=$pair_A_B_I1{$key}; $possible_pair_B_A_I1{$key}=$pair_B_A_I1{$key};
      #  }
    }
close OUTFI1;
open (OUTFR2,'>>', $outputfile_R2) or die "Could not open file '$outputfile_R2' $!";
foreach my $key (keys %pair_A_B_R2)
    {
      my @keys = split(/\s+/,$key); 
      print OUTFR2 ("$pair_A_B_R2{$key}\t$pair_B_A_R2{$key}\t$shift_R2_count{$keys[0]}\t$shift_R2_count{$keys[1]}\t$shift_R2{$key}\t$keys[0]\t$keys[1]\n");
      # print "$pair_A_B{$key}\t$pair_B_A{$key}\t$pair_seq{$keys[0]}\t$pair_seq{$keys[1]}\n";
      #if(($shift_R2_count{$keys[0]} < $shift_R2_count{$keys[1]})) ## this step include the threhold M>S
      #  {
          # print OUTFR2 ("$pair_A_B_R2{$key}\t$pair_B_A_R2{$key}\t$shift_R2_count{$keys[0]}\t$shift_R2_count{$keys[1]}\t$shift_R2{$key}\t$keys[0]\t$keys[1]\n");
      #    $possible_pair_A_B_R2{$key}=$pair_A_B_R2{$key}; $possible_pair_B_A_R2{$key}=$pair_B_A_R2{$key};
      #  }
    }
close OUTFR2;
##To review all the sequences and statistic all cases##

## Use threshold to delete all the real shifts###
my %delete_I1;
my %delete_R2;
my %delete_I1_ratio;
my %delete_R2_ratio;
# my $threshold_1=0.9; # to delete the high populational shifts
open (FILEI1, $outputfile_I1) or die "Could not open file '$outputfile_I1' $!";
while($gi=<FILEI1>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    # my $ratio = ($info[0]+$info[1])/$info[2];
    # my $threshold_2 = ($info[2]-2)/$info[2]; # to delete the low populational shifts
    if($info[2]<$info[3] && ($info[0]>=$info[1]))
        {
          if ($info[0]<$info[1]) {print "$info[5]\t$info[6]\n";}
          if(exists $delete_I1{$info[5]})
            {
             if ($delete_I1_ratio{$info[5]} > ($info[2]/$info[3])) ## if one shift has more than one possible mothers, using S/M (lowest) to choose one mother
                 {
                  $delete_I1{$info[5]} = $info[6]; $delete_I1_ratio{$info[5]} = $info[2]/$info[3];
                 }
            }
        else{ $delete_I1{$info[5]} = $info[6]; $delete_I1_ratio{$info[5]} = $info[2]/$info[3];}
        }
    }
close FILEI1;

open (FILER2, $outputfile_R2) or die "Could not open file '$outputfile_R2' $!";
while($gi=<FILER2>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    # my $ratio = ($info[0]+$info[1])/$info[2];
    # my $threshold_2 = ($info[2]-2)/$info[2]; # to delete the low populational shifts
    if($info[2]<$info[3] && ($info[0]>=$info[1]))
        {
          if ($info[0]<$info[1]) {print "$info[5]\t$info[6]\n";}
          if(exists $delete_R2{$info[5]} )
             {
              if ($delete_R2_ratio{$info[5]} > ($info[2]/$info[3]))
                 {
                   $delete_R2{$info[5]} = $info[6]; $delete_R2_ratio{$info[5]} = $info[2]/$info[3];
                 }
             }
        else{ $delete_R2{$info[5]} = $info[6]; $delete_R2_ratio{$info[5]} = $info[2]/$info[3];}
        }
    }
close FILER2;

my $delete_no=0;
foreach my $key (keys %delete_I1)
   { $delete_no++}
print "Totally found $delete_no shifts of I1, and start to delete them.....\n";
 $delete_no=0;
foreach my $key (keys %delete_R2)
   { $delete_no++}
print "Totally found $delete_no shifts of R2, and start to delete them.....\n";
open (FILE,$inputfile_sort) or die "Could not open file '$inputfile_sort' $!";
chomp($gi=<FILE>);@info=split(/\s+/,$gi);if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name = "cluster_"."$1";}
push @sequence, [@info];
while($gi=<FILE>)
   {
    chomp $gi;
    @info=split(/\s+/,$gi);
    if($info[0] =~ m{\Acluster_([0-9]*)}){$cluster_name_next = "cluster_"."$1";}
    if ($cluster_name_next eq $cluster_name){push @sequence, [@info];}
  else {
         &Delete_shift($cluster_name, \@sequence);
         undef @sequence;$cluster_name = $cluster_name_next;
         push @sequence, [@info];
        }
    }
&Delete_shift($cluster_name, \@sequence);
undef @sequence;
close FILE;
## Use threshold to delete all the real shifts###


#Find the shift sequence#
sub Find_shift
    {
     my ($k, $j, $m,  $seqseq,  $cluster_name, $I1_del, $R2_del);
     ($cluster_name, $seqseq)=@_;
     if($#$seqseq>0) 
        {
         for ($k=0; $k<$#$seqseq; $k++)
           {
             for ($j=($k+1); $j<=$#$seqseq; $j++)
              {
                $I1_del=10000; $R2_del=10000; ## they are not shifted sequences
                my $lI1=length($$seqseq[$k][2]); # print "$lI1\n";
                my $lR2=length($$seqseq[$k][3]); # print "$lR2\n"; die;
                 for ($m=0; $m<=$shiftcon; $m++)
                    {
                     if(substr($$seqseq[$k][2], $m) eq substr($$seqseq[$j][2], 0, ($lI1-$m)))
                        {
                         $I1_del=$m; last; 
                        }
                   elsif(substr($$seqseq[$k][2], 0, ($lI1-$m)) eq substr($$seqseq[$j][2], $m))
                        {
                         $I1_del=$m; last;
                        }
                    }
                 for ($m=0; $m<=$shiftcon; $m++)
                    {
                     if(substr($$seqseq[$k][3], $m) eq substr($$seqseq[$j][3], 0, ($lR2-$m)))
                        {
                         $R2_del=$m; last; 
                        }
                   elsif(substr($$seqseq[$k][3], 0, ($lR2-$m)) eq substr($$seqseq[$j][3], $m))
                        {
                         $R2_del=$m;last;
                        }
                    }
                #  print "$I1_del\t$R2_del\n"; 
                 if ($I1_del<=$shiftcon && $R2_del<=$shiftcon) 
                        {
                          my $seqs_s="$$seqseq[$k][2]"."$$seqseq[$k][3]";
                       #     print "$seqs_s\n";
                          my $seqs_m="$$seqseq[$j][2]"."$$seqseq[$j][3]";
                          my $seqs_pair="$seqs_s\t$seqs_m";
                          my $seqs_pair_r="$seqs_m\t$seqs_s";
                          $shift{$seqs_s} = $seqs_m;
                          $shift{$seqs_m} = $seqs_s;
                          $shift_pair{$seqs_pair} = $seqs_pair_r;
                          $shift_pair{$seqs_pair_r} = $seqs_pair;
                          if($$seqseq[$k][2] ne $$seqseq[$j][2])
                              {
                               my $pairs_I1="$$seqseq[$k][2]\t$$seqseq[$j][2]";
                               if(!(exists $shift_I1{$pairs_I1}))
                                   {
                                     $shift_I1{$pairs_I1}="$I1_del";
                                     my $pairs_I1_r="$$seqseq[$j][2]\t$$seqseq[$k][2]";
                                     $shift_I1{$pairs_I1_r}="$I1_del";
                                     $shift_I1_count{$$seqseq[$k][2]}=0; #if ($$seqseq[$k][2] eq "GTTTGCTCCCCACGCTTTCGAGCCTCAGCGTCAGTTATCGTCCAGTAAGCCGCCTTCGCCACTGGTGTTCCTCCTAATATCTACGCATTTCACCGCTACACTAGGAATTCCGCTTACCCCTCCGACACTCTAGTACGACAGTTTCCAATGCAGTGCCGGGGTTGAGCCCCGGGCTTTCACATCAGACTTGCCGCACCGCCTGCGCTCCCT") {print "yes\n";}
                                     $shift_I1_count{$$seqseq[$j][2]}=0; 
                                   }
                               }
                          if($$seqseq[$k][3] ne $$seqseq[$j][3])
                               {
                                 my $pairs_R2="$$seqseq[$k][3]\t$$seqseq[$j][3]";
                                 if(!(exists $shift_R2{$pairs_R2}))
                                    {
                                     $shift_R2{$pairs_R2}="$R2_del";
                                     my $pairs_R2_r="$$seqseq[$j][3]\t$$seqseq[$k][3]";
                                     $shift_R2{$pairs_R2_r}="$R2_del";
                                     $shift_R2_count{$$seqseq[$k][3]}=0;
                                     $shift_R2_count{$$seqseq[$j][3]}=0;
                                    }
                               }
                         }
                 }
            }
        }
     }

## review shifts

sub Review_shift
    {
      my ($cluster, $seq)=@_;
      my ($i, $j, %possible, %group, %group_I1, %group_R2);
      undef %possible;
      # print "$#$seq\n";
      for($i=0; $i<=$#$seq; $i++)
        {
         my $repseq="$$seq[$i][2]"."$$seq[$i][3]";
         # print "$repseq\n";
         if(exists $shift{$repseq})
            {
              $possible{$repseq}=\@{$$seq[$i]}; # print "$$seq[$i][0]\n";
            }
        }
      while(%possible)
         {
          undef %group;
          undef %group_I1;
          undef %group_R2;
          my @keykey=(keys %possible); # print "$#keykey\n";
          my $seed = $keykey[0];
          $group{$seed} = $possible{$seed};
          delete $possible{$seed};
          if(%possible)
             {
               foreach my $key (keys %possible)
                 {
                  my $pairs_seqs="$seed\t$key"; if(exists $shift_pair{$pairs_seqs}) {$group{$key} = $possible{$key}; delete $possible{$key};}
                 }
             }
          foreach my $key (keys %group)
                 {
                  if(exists $group_I1{${$group{$key}}[2]})
                      {
                       $group_I1{${$group{$key}}[2]}=$group_I1{${$group{$key}}[2]}+${$group{$key}}[1]; # print "${$group{$key}}[0]\t${$group{$key}}[1]\t${$group{$key}}[2]\n"; die;
                      }
                  else{
                       $group_I1{${$group{$key}}[2]}=${$group{$key}}[1];
                       }
                   if(exists $group_R2{${$group{$key}}[3]})
                       {
                        $group_R2{${$group{$key}}[3]}=$group_R2{${$group{$key}}[3]}+${$group{$key}}[1];
                       }
                   else{
                        $group_R2{${$group{$key}}[3]}=${$group{$key}}[1];
                       }
                  }
          my @keys=(keys %group_I1); # print "$#keys\n";
          if ($#keys>0)
             {
               for($i=0; $i<=($#keys-1); $i++)
                 {
                   for($j=$i+1; $j<=$#keys; $j++)
                      {
                        my $pairpair="$keys[$i]\t$keys[$j]";
                        my $pairpair_r="$keys[$j]\t$keys[$i]";
                        if (exists $shift_I1{$pairpair})
                            {
                              if($group_I1{$keys[$i]} >= $group_I1{$keys[$j]})
                                 {
                                   if (exists $pair_A_B_I1{$pairpair})
                                       {
                                          $pair_B_A_I1{$pairpair}++; $pair_A_B_I1{$pairpair_r}++;
                                       }
                                   else{
                                          $pair_A_B_I1{$pairpair}=0; $pair_B_A_I1{$pairpair}=1;
                                          $pair_A_B_I1{$pairpair_r}=1; $pair_B_A_I1{$pairpair_r}=0;
                                        }
                                  }
                             else {
                                     if (exists $pair_A_B_I1{$pairpair})
                                       {
                                          $pair_A_B_I1{$pairpair}++; $pair_B_A_I1{$pairpair_r}++;
                                       }
                                   else{
                                          $pair_A_B_I1{$pairpair}=1; $pair_B_A_I1{$pairpair}=0;
                                          $pair_A_B_I1{$pairpair_r}=0; $pair_B_A_I1{$pairpair_r}=1;
                                        }
                                  }
                              if(!(exists $shift_I1{$pairpair_r})) {print "Somthing is wrong!!\n";}
                            }
                      }
                 }
             }
         foreach my $key (keys %group_I1)
             {
               $shift_I1_count{$key}++;
             }
        @keys=(keys %group_R2);  
        if ($#keys>0)
             {
               for($i=0; $i<=($#keys-1); $i++)
                 {
                   for($j=$i+1; $j<=$#keys; $j++)
                      {
                        my $pairpair="$keys[$i]\t$keys[$j]";
                        my $pairpair_r="$keys[$j]\t$keys[$i]";
                        if (exists $shift_R2{$pairpair})
                            {
                              if($group_R2{$keys[$i]} >= $group_R2{$keys[$j]})
                                 {
                                   if (exists $pair_A_B_R2{$pairpair})
                                       {
                                          $pair_B_A_R2{$pairpair}++; $pair_A_B_R2{$pairpair_r}++;
                                       }
                                   else{
                                          $pair_A_B_R2{$pairpair}=0; $pair_B_A_R2{$pairpair}=1;
                                          $pair_A_B_R2{$pairpair_r}=1; $pair_B_A_R2{$pairpair_r}=0;
                                        }
                                  }
                             else {
                                     if (exists $pair_A_B_R2{$pairpair})
                                       {
                                          $pair_A_B_R2{$pairpair}++; $pair_B_A_R2{$pairpair_r}++;
                                       }
                                   else{
                                          $pair_A_B_R2{$pairpair}=1; $pair_B_A_R2{$pairpair}=0;
                                          $pair_A_B_R2{$pairpair_r}=0; $pair_B_A_R2{$pairpair_r}=1;
                                        }
                                  }
                              if(!(exists $shift_R2{$pairpair_r})) {print "Somthing is wrong!!\n";}
                            }
                      }
                 }
             }
         foreach my $key (keys %group_R2)
            {
               $shift_R2_count{$key}++;
            }      
       }
    }

sub Delete_shift {
      my ($cluster, $seq)=@_;
      my %correct;
      my %correct_reads;
      my %correct_cluster;
      for(my $i=0; $i<=$#$seq; $i++)
          {
            if(exists $delete_I1{$$seq[$i][2]})
                {
                  $$seq[$i][2] = $delete_I1{$$seq[$i][2]};
                }
             if(exists $delete_R2{$$seq[$i][3]})
                {
                  $$seq[$i][3] = $delete_R2{$$seq[$i][3]};
                }
             my $seqseq="$$seq[$i][2]"."$$seq[$i][3]";
             if($correct{$seqseq})
               {
                 $correct_reads{$seqseq}=$correct_reads{$seqseq}+$$seq[$i][1];
               }
           else{
                 $correct{$seqseq}="$$seq[$i][2]\t$$seq[$i][3]";
                 $correct_reads{$seqseq}=$$seq[$i][1];
                 $correct_cluster{$seqseq}=$$seq[$i][0];
               }
           }
        open (OUTF,'>>', $outputfile) or die "Could not open file '$outputfile' $!";
        foreach my $key (keys %correct)
          {
            print OUTF ("$correct_cluster{$key}\t$correct_reads{$key}\t$correct{$key}\n");
          }
       close OUTF;
   }
       
# unlink $inputfile_sort;
print "Done!!!\n";
##Get one cluster's data and find the shift##

##end##

#####Author#####
#Jianshi Frank Jin

#####Version#####
#V1.001
#2018.10.03
